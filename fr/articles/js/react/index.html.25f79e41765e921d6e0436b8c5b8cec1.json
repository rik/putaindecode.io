{"head":{"layout":"Post","comments":true,"date":"2014-06-04","title":"Introduction à ReactJS","tags":["javascript","reactjs"],"authors":["bloodyowl"],"description":"Cela fait maintenant un an que ReactJS est open-sourced. C'est l'occasion de présenter le petit dernier de la vague MV\\*. Les différentes…"},"body":"<p>Cela fait maintenant un an que ReactJS est open-sourced. C'est l'occasion de\nprésenter le petit dernier de la vague MV*.</p>\n<h2 id=\"les-différentes-approches-dui\"><a href=\"#les-diff%C3%A9rentes-approches-dui\" class=\"phenomic-HeadingAnchor\">#</a>Les différentes approches d'UI</h2>\n<h3 id=\"backbone\"><a href=\"#backbone\" class=\"phenomic-HeadingAnchor\">#</a>Backbone</h3>\n<p><a href=\"http://backbonejs.org\">Backbone</a> apporte une simplification dans la déclaration\nd'évenements, il reste cependant très peu impliqué dans le rendering. Le choix\nde laisser l'utilisateur décider de tout concernant <code>Backbone.View</code> est positif\npour de nombreux projets, mais rend la gestion du DOM pénible.</p>\n<p>Pour faire du data-binding, <code>Backbone</code> ne propose naturellement rien, et l'on\ndoit faire appel à des mixins supplémentaires pour le mettre en place sans\ns'arracher les cheveux.</p>\n<p>De plus, c'est souvent un moteur de templating comme Handlebars ou Jade qui\ngénére la vue originale. On se retrouve donc avec un joli\n<code>this.$el.html(this.template(data))</code> dans la méthode <code>render()</code> qui va provoquer\ndes jolies horreurs visuelles (ie. les images se rechargent, les videos sont\nréinitialisées).</p>\n<p>En somme, Backbone est très sympathique pour structurer son code proprement,\nmais concernant l'UI, n'aide absolument pas à réduire la compléxité liée aux\nétats du DOM.</p>\n<h3 id=\"angular\"><a href=\"#angular\" class=\"phenomic-HeadingAnchor\">#</a>Angular</h3>\n<p><a href=\"https://angularjs.org\">Angular</a> propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing) et\non déclare ses bindings très simplement avec une syntaxe <code>{{mustache}}</code>.</p>\n<p>On déclare les évenements à l'aide d'attributs <code>ng-{eventName}</code>.</p>\n<p>Sur le papier, angular est donc très sympathique (je ne prendrais pas parti sur\nle dirty checking).</p>\n<h3 id=\"ember\"><a href=\"#ember\" class=\"phenomic-HeadingAnchor\">#</a>Ember</h3>\n<p><a href=\"http://emberjs.com\">Ember</a> est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de <code>data-binding</code> à l'aide de <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/range\">DOM\nRanges</a>. Il propose des\nconventions fortes, et contrairement à la plupart des <em>a priori</em>, est très\nsimple à prendre en main. Les subviews sont très simples à utiliser à l'aide\nd'<code>{{outlet}}</code>.</p>\n<p>Pour résumer, ember et angular proposent de vraies solutions pour la gestion de\nl'UI. Cependant les deux conservent cette démarche :</p>\n<ul>\n<li>on <em>render</em> (génère et insère le bout de DOM) une fois</li>\n<li>on update les bindings</li>\n</ul>\n<h3 id=\"react\"><a href=\"#react\" class=\"phenomic-HeadingAnchor\">#</a>React</h3>\n<p><a href=\"http://facebook.github.io/react/\">React</a> change complètement d'approche. Il\npart d'un constat simple : le fait que le DOM ait constamment un état différent,\nc'est chiant à gérer.</p>\n<p>Du coup, et si on appelait <code>.render()</code> à chaque modification ? Ça a l'air\nstupide, hein ? Pas tant que ça en fait.</p>\n<p>React implémente un <strong>DOM virtuel</strong>, une représentation interne du DOM\nextrêmement rapide. Il inclut par ailleurs son propre système d'événements, ce\nqui permet à React de faire bénéficier de la phase de capturing aux navigateurs\nn'implémentant pas <code>EventTarget</code> (oui, IE8, c'est toi que je regarde).</p>\n<p>La méthode <code>render</code> retourne des objets correspondant à la représentation\ninterne du DOM virtuel.</p>\n<p>Les classes React se définissent par leur <code>state</code>. Lorsque l'on crée une classe,\non définit une méthode <code>getInitialState</code> qui retournera un état initial.</p>\n<p>Après cela, le seul moyen de changer l'état est d'indiquer à <code>this.setState</code>\nquelles valeurs de l'état ont changé afin de mettre à jour le DOM.</p>\n<p>Une classe React se voit passer des propriétés au moment d'être instanciée : les\n<code>props</code>. À ne pas confondre avec le <code>state</code>, son contenu ne doit être manipulé\nque par l'extérieur de la classe (bien que celle-ci puisse obtenir des valeurs\npar défaut en définissant une méthode <code>getDefaultProps</code> qui les retourne).</p>\n<p>Le <code>state</code>, en revanche, ne doit être modifié qu'au sein des méthodes propres à\nla classe.</p>\n<p>Le principal avantage est que l'on est certain, du fait de l'appel systématique\nà <code>render</code>, que notre composant React aura la représentation attendue pour un\nétat donné.</p>\n<p>Un des autres avantages de React est son algorithme de diff interne. Le DOM\nvirtuel va être comparé avec la version visible, et React effectue à l'aide\nd'opérations simples les seuls changements nécessaires.</p>\n<p>Cela résoud des problématiques comme la position du curseur dans un champ texte\nqui effectue du two-way data-binding; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le\nfocus. Du même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.</p>\n<p>React est idéalement utilisé avec jsx, un pré-processeur js qui permet d'écrire\nles templates avec une syntaxe xml (voir l'exemple plus bas), ce qui permet à\ndes novices de le prendre en main très rapidement.</p>\n<h2 id=\"créons-un-component-react-\"><a href=\"#cr%C3%A9ons-un-component-react-\" class=\"phenomic-HeadingAnchor\">#</a>Créons un component react :</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> View = React.createClass({\n  <span class=\"hljs-attr\">getInitialState</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// état initial</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-literal\">false</span>\n    };\n  },\n  <span class=\"hljs-attr\">getDefaultProps</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// si `this.props.label` n'est pas présent, ce sera `\"?\"`</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">\"?\"</span>\n    };\n  },\n  <span class=\"hljs-attr\">toggle</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// on crée un nouvel état (les états de react sont immutable)</span>\n    <span class=\"hljs-comment\">// et on déclenche le render</span>\n    <span class=\"hljs-keyword\">this</span>.setState({\n      <span class=\"hljs-attr\">checked</span>: !<span class=\"hljs-keyword\">this</span>.state.checked\n    });\n  },\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// petit addon pour se simplifier la vie</span>\n    <span class=\"hljs-keyword\">var</span> classes = React.addons.classSet({\n      <span class=\"hljs-string\">\"list-item\"</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-string\">\"list-item--valid\"</span>: <span class=\"hljs-keyword\">this</span>.state.checked\n    });\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{classes}</span>></span>\n        {/* notre binding tout simple */}\n        </span>&#x3C;input\n          checked={this.state.checked}\n          type=\"checkbox\"\n          onChange={this.toggle}\n        />\n        {this.props.label}\n      &#x3C;/div><span class=\"xml\">\n    );\n  }\n});\n\n// on mount le component, et l'on passe le label\nvar view = React.render(\n  </span>&#x3C;View label=\"helloworld\" />,\n  document.getElementById(\"id\")\n);\n// et hop\nview.toggle();</code></pre>\n<h2 id=\"sum-up-des-avantages-de-react\"><a href=\"#sum-up-des-avantages-de-react\" class=\"phenomic-HeadingAnchor\">#</a>Sum up des avantages de React</h2>\n<p>React a bien compris ces points :</p>\n<ul>\n<li>le DOM est lent, du moins en écriture, et limiter les interactions avec ce\ndernier est essentiel ;</li>\n<li>devoir continuellement penser à l'état du DOM à l'instant <code>n</code> n'est pas une\npréoccupation que nous devrions avoir en développant l'UI de nos composants ;</li>\n<li>les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\nchaque changement) et de composition (composer une classe de différentes\nfonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\ngrands intérêts, trop peu utilisés en front-end.</li>\n</ul>\n<p>En bonus, React, même s'il n'impose pas de bibliothèque pour les data et la\ncommunication des modules, offre une approche nommée\n<a href=\"http://facebook.github.io/flux/docs/overview.html\">flux</a> très intéressante et\nvous offrant des clés pour concevoir une app avec en tête les paradigmes pensés\npour React.</p>\n<p>Last but not least, vous pouvez render vos composants React depuis le serveur et\nla lib sera assez intelligente pour reconnaitre les composants déjà générés pour\nne pas les render systématiquement, c'est pas beau, ça ?</p>\n","rawBody":"\nCela fait maintenant un an que ReactJS est open-sourced. C'est l'occasion de\nprésenter le petit dernier de la vague MV\\*.\n\n## Les différentes approches d'UI\n\n### Backbone\n\n[Backbone](http://backbonejs.org) apporte une simplification dans la déclaration\nd'évenements, il reste cependant très peu impliqué dans le rendering. Le choix\nde laisser l'utilisateur décider de tout concernant `Backbone.View` est positif\npour de nombreux projets, mais rend la gestion du DOM pénible.\n\nPour faire du data-binding, `Backbone` ne propose naturellement rien, et l'on\ndoit faire appel à des mixins supplémentaires pour le mettre en place sans\ns'arracher les cheveux.\n\nDe plus, c'est souvent un moteur de templating comme Handlebars ou Jade qui\ngénére la vue originale. On se retrouve donc avec un joli\n`this.$el.html(this.template(data))` dans la méthode `render()` qui va provoquer\ndes jolies horreurs visuelles (ie. les images se rechargent, les videos sont\nréinitialisées).\n\nEn somme, Backbone est très sympathique pour structurer son code proprement,\nmais concernant l'UI, n'aide absolument pas à réduire la compléxité liée aux\nétats du DOM.\n\n### Angular\n\n[Angular](https://angularjs.org) propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing) et\non déclare ses bindings très simplement avec une syntaxe `{{mustache}}`.\n\nOn déclare les évenements à l'aide d'attributs `ng-{eventName}`.\n\nSur le papier, angular est donc très sympathique (je ne prendrais pas parti sur\nle dirty checking).\n\n### Ember\n\n[Ember](http://emberjs.com) est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de `data-binding` à l'aide de [DOM\nRanges](https://developer.mozilla.org/en-US/docs/Web/API/range). Il propose des\nconventions fortes, et contrairement à la plupart des *a priori*, est très\nsimple à prendre en main. Les subviews sont très simples à utiliser à l'aide\nd'`{{outlet}}`.\n\nPour résumer, ember et angular proposent de vraies solutions pour la gestion de\nl'UI. Cependant les deux conservent cette démarche :\n\n* on _render_ (génère et insère le bout de DOM) une fois\n* on update les bindings\n\n### React\n\n[React](http://facebook.github.io/react/) change complètement d'approche. Il\npart d'un constat simple : le fait que le DOM ait constamment un état différent,\nc'est chiant à gérer.\n\nDu coup, et si on appelait `.render()` à chaque modification ? Ça a l'air\nstupide, hein ? Pas tant que ça en fait.\n\nReact implémente un **DOM virtuel**, une représentation interne du DOM\nextrêmement rapide. Il inclut par ailleurs son propre système d'événements, ce\nqui permet à React de faire bénéficier de la phase de capturing aux navigateurs\nn'implémentant pas `EventTarget` (oui, IE8, c'est toi que je regarde).\n\nLa méthode `render` retourne des objets correspondant à la représentation\ninterne du DOM virtuel.\n\nLes classes React se définissent par leur `state`. Lorsque l'on crée une classe,\non définit une méthode `getInitialState` qui retournera un état initial.\n\nAprès cela, le seul moyen de changer l'état est d'indiquer à `this.setState`\nquelles valeurs de l'état ont changé afin de mettre à jour le DOM.\n\nUne classe React se voit passer des propriétés au moment d'être instanciée : les\n`props`. À ne pas confondre avec le `state`, son contenu ne doit être manipulé\nque par l'extérieur de la classe (bien que celle-ci puisse obtenir des valeurs\npar défaut en définissant une méthode `getDefaultProps` qui les retourne).\n\nLe `state`, en revanche, ne doit être modifié qu'au sein des méthodes propres à\nla classe.\n\nLe principal avantage est que l'on est certain, du fait de l'appel systématique\nà `render`, que notre composant React aura la représentation attendue pour un\nétat donné.\n\nUn des autres avantages de React est son algorithme de diff interne. Le DOM\nvirtuel va être comparé avec la version visible, et React effectue à l'aide\nd'opérations simples les seuls changements nécessaires.\n\nCela résoud des problématiques comme la position du curseur dans un champ texte\nqui effectue du two-way data-binding; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le\nfocus. Du même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.\n\nReact est idéalement utilisé avec jsx, un pré-processeur js qui permet d'écrire\nles templates avec une syntaxe xml (voir l'exemple plus bas), ce qui permet à\ndes novices de le prendre en main très rapidement.\n\n## Créons un component react :\n\n```javascript\nvar View = React.createClass({\n  getInitialState: function() {\n    // état initial\n    return {\n      checked: false\n    };\n  },\n  getDefaultProps: function() {\n    // si `this.props.label` n'est pas présent, ce sera `\"?\"`\n    return {\n      label: \"?\"\n    };\n  },\n  toggle: function() {\n    // on crée un nouvel état (les états de react sont immutable)\n    // et on déclenche le render\n    this.setState({\n      checked: !this.state.checked\n    });\n  },\n  render: function() {\n    // petit addon pour se simplifier la vie\n    var classes = React.addons.classSet({\n      \"list-item\": true,\n      \"list-item--valid\": this.state.checked\n    });\n    return (\n      <div className={classes}>\n        {/* notre binding tout simple */}\n        <input\n          checked={this.state.checked}\n          type=\"checkbox\"\n          onChange={this.toggle}\n        />\n        {this.props.label}\n      </div>\n    );\n  }\n});\n\n// on mount le component, et l'on passe le label\nvar view = React.render(\n  <View label=\"helloworld\" />,\n  document.getElementById(\"id\")\n);\n// et hop\nview.toggle();\n```\n\n## Sum up des avantages de React\n\nReact a bien compris ces points :\n\n* le DOM est lent, du moins en écriture, et limiter les interactions avec ce\n  dernier est essentiel ;\n* devoir continuellement penser à l'état du DOM à l'instant `n` n'est pas une\n  préoccupation que nous devrions avoir en développant l'UI de nos composants ;\n* les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\n  chaque changement) et de composition (composer une classe de différentes\n  fonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\n  grands intérêts, trop peu utilisés en front-end.\n\nEn bonus, React, même s'il n'impose pas de bibliothèque pour les data et la\ncommunication des modules, offre une approche nommée\n[flux](http://facebook.github.io/flux/docs/overview.html) très intéressante et\nvous offrant des clés pour concevoir une app avec en tête les paradigmes pensés\npour React.\n\nLast but not least, vous pouvez render vos composants React depuis le serveur et\nla lib sera assez intelligente pour reconnaitre les composants déjà générés pour\nne pas les render systématiquement, c'est pas beau, ça ?\n","__filename":"fr/articles/js/react/index.md","__url":"/fr/articles/js/react/","__resourceUrl":"/fr/articles/js/react/index.html","__dataUrl":"/fr/articles/js/react/index.html.25f79e41765e921d6e0436b8c5b8cec1.json"}